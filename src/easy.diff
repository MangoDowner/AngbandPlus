diff -u src-orig/cmd1.c src/cmd1.c
--- src-orig/cmd1.c	Wed Feb 11 03:30:28 1998
+++ src/cmd1.c	Sun Feb 22 18:10:32 1998
@@ -1076,6 +1076,17 @@
 		py_attack(y, x);
 	}

+#ifdef ALLOW_EASY_DISARM /* TNB */
+	/* Disarm a visible trap */
+	else if ((do_pickup != easy_disarm) &&
+		(cave_feat[y][x] >= FEAT_TRAP_HEAD) &&
+		(cave_feat[y][x] <= FEAT_TRAP_TAIL))
+	{
+		extern bool do_cmd_disarm_aux(int y, int x);
+		(void) do_cmd_disarm_aux(y, x);
+	}
+#endif /* ALLOW_EASY_DISARM */
+
 	/* Player can not walk through "walls" */
 	else if (!cave_floor_bold(y, x))
 	{
@@ -1122,6 +1133,9 @@
 			/* Closed door */
 			else if (cave_feat[y][x] < FEAT_SECRET)
 			{
+#ifdef ALLOW_EASY_OPEN /* TNB */
+				if (easy_open_door(y, x)) return;
+#endif
 				msg_print("There is a door blocking your way.");
 			}

@@ -1164,7 +1178,11 @@
 		}

 		/* Handle "objects" */
+#ifdef ALLOW_EASY_DISARM /* TNB */
+		py_pickup(do_pickup != always_pickup);
+#else
 		py_pickup(do_pickup);
+#endif /* ALLOW_EASY_DISARM */

 		/* Handle "store doors" */
 		if ((cave_feat[y][x] >= FEAT_SHOP_HEAD) &&
@@ -1935,6 +1953,10 @@
 	p_ptr->energy_use = 100;

 	/* Move the player, using the "pickup" flag */
+#ifdef ALLOW_EASY_DISARM /* TNB */
+	move_player(p_ptr->run_cur_dir, FALSE);
+#else
 	move_player(p_ptr->run_cur_dir, always_pickup);
+#endif /* ALLOW_EASY_DISARM */
 }

diff -u src-orig/cmd2.c src/cmd2.c
--- src-orig/cmd2.c	Fri Feb  6 01:10:32 1998
+++ src/cmd2.c	Sun Feb 22 18:18:50 1998
@@ -471,6 +471,205 @@
 	return (more);
 }

+#ifdef ALLOW_EASY_OPEN /* TNB */
+
+/*
+ * easy_open_door --
+ *
+ *	If there is a jammed/closed/locked door at the given location,
+ *	then attempt to unlock/open it. Return TRUE if an attempt was
+ *	made (successful or not), otherwise return FALSE.
+ *
+ *	The code here should be nearly identical to that in
+ *	do_cmd_open_test() and do_cmd_open_aux().
+ */
+
+bool easy_open_door(int y, int x)
+{
+	int i, j;
+
+	/* Must be a closed door */
+	if (!((cave_feat[y][x] >= FEAT_DOOR_HEAD) &&
+	      (cave_feat[y][x] <= FEAT_DOOR_TAIL)))
+	{
+		/* Nope */
+		return (FALSE);
+	}
+
+	/* Jammed door */
+	if (cave_feat[y][x] >= FEAT_DOOR_HEAD + 0x08)
+	{
+		/* Stuck */
+		msg_print("The door appears to be stuck.");
+	}
+
+	/* Locked door */
+	else if (cave_feat[y][x] >= FEAT_DOOR_HEAD + 0x01)
+	{
+		/* Disarm factor */
+		i = p_ptr->skill_dis;
+
+		/* Penalize some conditions */
+		if (p_ptr->blind || no_lite()) i = i / 10;
+		if (p_ptr->confused || p_ptr->image) i = i / 10;
+
+		/* Extract the lock power */
+		j = cave_feat[y][x] - FEAT_DOOR_HEAD;
+
+		/* Extract the difficulty XXX XXX XXX */
+		j = i - (j * 4);
+
+		/* Always have a small chance of success */
+		if (j < 2) j = 2;
+
+		/* Success */
+		if (rand_int(100) < j)
+		{
+			/* Message */
+			msg_print("You have picked the lock.");
+
+			/* Open the door */
+			cave_set_feat(y, x, FEAT_OPEN);
+
+			/* Update some things */
+			p_ptr->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
+
+			/* Sound */
+			sound(SOUND_OPENDOOR);
+
+			/* Experience */
+			gain_exp(1);
+		}
+
+		/* Failure */
+		else
+		{
+			/* Failure */
+			if (flush_failure) flush();
+
+			/* Message */
+			msg_print("You failed to pick the lock.");
+		}
+	}
+
+	/* Closed door */
+	else
+	{
+		/* Open the door */
+		cave_set_feat(y, x, FEAT_OPEN);
+
+		/* Update some things */
+		p_ptr->update |= (PU_UPDATE_VIEW | PU_MONSTERS);
+
+		/* Sound */
+		sound(SOUND_OPENDOOR);
+	}
+
+	/* Result */
+	return (TRUE);
+}
+
+/*
+ * Return the number of features around (or under) the character.
+ * Usually look for doors and floor traps.
+ */
+static int count_dt(int *y, int *x, byte f1, byte f2)
+{
+	int d, count;
+
+	/* Count how many matches */
+	count = 0;
+
+	/* Check around (and under) the character */
+	for (d = 0; d < 9; d++) {
+
+		/* Extract adjacent (legal) location */
+		int yy = p_ptr->py + ddy_ddd[d];
+		int xx = p_ptr->px + ddx_ddd[d];
+
+		/* Must have knowledge */
+		if (!(cave_info[yy][xx] & (CAVE_MARK))) continue;
+
+		/* Not looking for this feature */
+		if (cave_feat[yy][xx] < f1) continue;
+		if (cave_feat[yy][xx] > f2) continue;
+
+		/* OK */
+		++count;
+
+		/* Remember the location. Only useful if only one match */
+		*y = yy;
+		*x = xx;
+	}
+
+	/* All done */
+	return count;
+}
+
+/*
+ * Return the number of chests around (or under) the character.
+ * If requested, count only trapped chests.
+ */
+static int count_chests(int *y, int *x, bool trapped)
+{
+	int d, count, o_idx;
+
+	object_type *o_ptr;
+
+	/* Count how many matches */
+	count = 0;
+
+	/* Check around (and under) the character */
+	for (d = 0; d < 9; d++) {
+
+		/* Extract adjacent (legal) location */
+		int yy = p_ptr->py + ddy_ddd[d];
+		int xx = p_ptr->px + ddx_ddd[d];
+
+		/* No (visible) chest is there */
+		if ((o_idx = chest_check(yy, xx)) == 0) continue;
+
+		/* Grab the object */
+		o_ptr = &o_list[o_idx];
+
+		/* Already open */
+		if (o_ptr->pval == 0) continue;
+
+		/* No (known) traps here */
+		if (trapped && (!object_known_p(o_ptr) ||
+			!chest_traps[o_ptr->pval])) continue;
+
+		/* OK */
+		++count;
+
+		/* Remember the location. Only useful if only one match */
+		*y = yy;
+		*x = xx;
+	}
+
+	/* All done */
+	return count;
+}
+
+/*
+ * Convert an adjacent location to a direction.
+ */
+static int coords_to_dir(int y, int x)
+{
+    int d[3][3] = { 7, 4, 1, 8, 5, 2, 9, 6, 3 };
+    int dy, dx;
+
+    dy = y - p_ptr->py;
+    dx = x - p_ptr->px;
+
+    /* Paranoia */
+    if (ABS(dx) > 1 || ABS(dy) > 1) return (0);
+
+    return d[dx + 1][dy + 1];
+}
+
+#endif /* ALLOW_EASY_OPEN */
+

 /*
  * Determine if a given grid may be "opened"
@@ -615,6 +814,28 @@

 	bool more = FALSE;

+#ifdef ALLOW_EASY_OPEN /* TNB */
+
+	/* Option: Pick a direction */
+	if (easy_open) {
+
+	    int num_doors, num_chests;
+
+	    /* Count closed doors (locked or jammed) */
+	    num_doors = count_dt(&y, &x, FEAT_DOOR_HEAD, FEAT_DOOR_TAIL);
+
+	    /* Count chests (locked) */
+	    num_chests = count_chests(&y, &x, FALSE);
+
+	    /* See if only one target */
+	    if (num_doors || num_chests) {
+	        bool too_many = (num_doors && num_chests) || (num_doors > 1) ||
+				(num_chests > 1);
+	        if (!too_many) p_ptr->command_dir = coords_to_dir(y, x);
+	    }
+	}
+
+#endif /* ALLOW_EASY_OPEN */

 	/* Get a direction (or abort) */
 	if (!get_rep_dir(&dir)) return;
@@ -772,6 +993,18 @@

 	bool more = FALSE;

+#ifdef ALLOW_EASY_OPEN /* TNB */
+
+	/* Option: Pick a direction */
+	if (easy_open) {
+
+		/* Count open doors */
+		if (count_dt(&y, &x, FEAT_OPEN, FEAT_OPEN) == 1) {
+			p_ptr->command_dir = coords_to_dir(y, x);
+		}
+	}
+
+#endif /* ALLOW_EASY_OPEN */

 	/* Get a direction (or abort) */
 	if (!get_rep_dir(&dir)) return;
@@ -1200,7 +1433,11 @@
  *
  * Returns TRUE if repeated commands may continue
  */
+#ifdef ALLOW_EASY_DISARM /* TNB */
+bool do_cmd_disarm_aux(int y, int x)
+#else
 static bool do_cmd_disarm_aux(int y, int x)
+#endif
 {
 	int i, j, power;

@@ -1292,6 +1529,28 @@

 	bool more = FALSE;

+#ifdef ALLOW_EASY_DISARM /* TNB */
+
+	/* Option: Pick a direction */
+	if (easy_disarm) {
+
+	    int num_traps, num_chests;
+
+	    /* Count visible traps */
+	    num_traps = count_dt(&y, &x, FEAT_TRAP_HEAD, FEAT_TRAP_TAIL);
+
+	    /* Count chests (trapped) */
+	    num_chests = count_chests(&y, &x, TRUE);
+
+	    /* See if only one target */
+	    if (num_traps || num_chests) {
+	        bool too_many = (num_traps && num_chests) || (num_traps > 1) ||
+				(num_chests > 1);
+	        if (!too_many) p_ptr->command_dir = coords_to_dir(y, x);
+	    }
+	}
+
+#endif /* ALLOW_EASY_DISARM */

 	/* Get a direction (or abort) */
 	if (!get_rep_dir(&dir)) return;
@@ -1851,6 +2110,9 @@
 		/* Door */
 		else if (cave_feat[y][x] < FEAT_SECRET)
 		{
+#ifdef ALLOW_EASY_OPEN /* TNB */
+			return (TRUE);
+#endif
 			/* Message */
 			msg_print("There is a door in the way!");
 		}
@@ -1934,7 +2196,11 @@
 void do_cmd_walk(void)
 {
 	/* Move (usually pickup) */
+#ifdef ALLOW_EASY_DISARM /* TNB */
+	do_cmd_walk_or_jump(FALSE);
+#else
 	do_cmd_walk_or_jump(always_pickup);
+#endif /* ALLOW_EASY_DISARM */
 }


@@ -1944,7 +2210,11 @@
 void do_cmd_jump(void)
 {
 	/* Move (usually do not pickup) */
+#ifdef ALLOW_EASY_DISARM /* TNB */
+	do_cmd_walk_or_jump(TRUE);
+#else
 	do_cmd_walk_or_jump(!always_pickup);
+#endif
 }


diff -u src-orig/cmd5.c src/cmd5.c
--- src-orig/cmd5.c	Wed Feb 11 03:30:28 1998
+++ src/cmd5.c	Mon Feb 16 17:21:08 1998
@@ -42,6 +42,20 @@

 	cptr p = ((mp_ptr->spell_book == TV_MAGIC_BOOK) ? "spell" : "prayer");

+#ifdef ALLOW_REPEAT /* TNB */
+
+    /* Get the spell, if available */
+    if (repeat_pull(sn)) {
+
+        /* Verify the spell */
+        if (spell_okay(*sn, known)) {
+
+            /* Success */
+            return (TRUE);
+        }
+    }
+
+#endif

 	/* Extract spells */
 	for (spell = 0; spell < 64; spell++)
@@ -200,6 +214,12 @@

 	/* Save the choice */
 	(*sn) = spell;
+
+#ifdef ALLOW_REPEAT /* TNB */
+
+    repeat_push(*sn);
+
+#endif

 	/* Success */
 	return (TRUE);
diff -u src-orig/config.h src/config.h
--- src-orig/config.h	Wed Feb 11 03:30:28 1998
+++ src/config.h	Fri Feb  6 01:10:30 1998
@@ -517,3 +517,17 @@
 #endif


+/*
+ * OPTION: Repeat last command -- TNB
+ */
+#define ALLOW_REPEAT
+
+/*
+ * OPTION: Make opening and closing things easy -- TNB
+ */
+#define ALLOW_EASY_OPEN
+
+/*
+ * OPTION: Make disarming traps easy -- TNB
+ */
+#define ALLOW_EASY_DISARM
diff -u src-orig/defines.h src/defines.h
--- src-orig/defines.h	Wed Feb 11 03:30:28 1998
+++ src/defines.h	Fri Feb  6 01:10:30 1998
@@ -2289,7 +2289,11 @@
 #define OPT_verify_destroy			28
 #define OPT_verify_special			29
 #define OPT_allow_quantity			30
+#ifdef ALLOW_EASY_OPEN /* TNB */
+#define OPT_easy_open 31
+#else
 /* xxx */
+#endif /* ALLOW_EASY_OPEN */
 #define OPT_auto_haggle				32
 #define OPT_auto_scum				33
 #define OPT_testing_stack			34
@@ -2302,7 +2306,10 @@
 #define OPT_dungeon_stair			41
 #define OPT_flow_by_sound			42
 #define OPT_flow_by_smell			43
+#ifdef ALLOW_EASY_DISARM /* TNB */
+#define OPT_easy_disarm 44
 /* xxx */
+#endif /* ALLOW_EASY_DISARM */
 /* xxx */
 #define OPT_smart_learn				46
 #define OPT_smart_cheat				47
@@ -2359,7 +2366,11 @@
 #define verify_destroy			op_ptr->opt[OPT_verify_destroy]
 #define verify_special			op_ptr->opt[OPT_verify_special]
 #define allow_quantity			op_ptr->opt[OPT_allow_quantity]
+#ifdef ALLOW_EASY_OPEN /* TNB */
+#define easy_open			op_ptr->opt[OPT_easy_open]
+#else
 /* xxx */
+#endif /* ALLOW_EASY_OPEN */
 #define auto_haggle				op_ptr->opt[OPT_auto_haggle]
 #define auto_scum				op_ptr->opt[OPT_auto_scum]
 #define testing_stack			op_ptr->opt[OPT_testing_stack]
@@ -2372,7 +2383,10 @@
 #define dungeon_stair			op_ptr->opt[OPT_dungeon_stair]
 #define flow_by_sound			op_ptr->opt[OPT_flow_by_sound]
 #define flow_by_smell			op_ptr->opt[OPT_flow_by_smell]
+#ifdef ALLOW_EASY_DISARM /* TNB */
+#define easy_disarm			op_ptr->opt[OPT_easy_disarm]
 /* xxx */
+#endif /* ALLOW_EASY_DISARM */
 /* xxx */
 #define smart_learn				op_ptr->opt[OPT_smart_learn]
 #define smart_cheat				op_ptr->opt[OPT_smart_cheat]
diff -u src-orig/dungeon.c src/dungeon.c
--- src-orig/dungeon.c	Wed Feb 11 03:30:28 1998
+++ src/dungeon.c	Mon Feb 16 17:40:00 1998
@@ -1161,13 +1161,19 @@
 #endif


-
 /*
  * Parse and execute the current command
  * Give "Warning" on illegal commands.
  */
 static void process_command(void)
 {
+#ifdef ALLOW_REPEAT /* TNB */
+
+    /* Handle repeating the last command */
+    repeat_check();
+
+#endif /* ALLOW_REPEAT */
+
 	/* Parse the command */
 	switch (p_ptr->command_cmd)
 	{
diff -u src-orig/object1.c src/object1.c
--- src-orig/object1.c	Wed Feb 11 03:30:30 1998
+++ src/object1.c	Mon Feb 16 17:21:16 1998
@@ -3542,6 +3542,57 @@
 	char tmp_val[160];
 	char out_val[160];

+#ifdef ALLOW_REPEAT /* TNB */
+
+    /* Get the item index */
+    if (repeat_pull(cp)) {
+
+        /* Floor item? */
+        if (*cp < 0) {
+
+			/* Scan all objects in the grid */
+			for (this_o_idx = cave_o_idx[py][px]; this_o_idx; this_o_idx = next_o_idx)
+			{
+				object_type *o_ptr;
+
+				/* Acquire object */
+				o_ptr = &o_list[this_o_idx];
+
+				/* Acquire next object */
+				next_o_idx = o_ptr->next_o_idx;
+
+				/* Validate the item */
+				if (!item_tester_okay(o_ptr)) continue;
+
+				/* Save the index */
+				(*cp) = 0 - this_o_idx;
+
+				/* Forget the item_tester_tval restriction */
+				item_tester_tval = 0;
+
+				/* Forget the item_tester_hook restriction */
+				item_tester_hook = NULL;
+
+				/* Success */
+				return (TRUE);
+	        }
+        }
+
+        /* Verify the item */
+        else if (get_item_okay(*cp)) {
+
+	        /* Forget the item_tester_tval restriction */
+	        item_tester_tval = 0;
+
+	        /* Forget the item_tester_hook restriction */
+	        item_tester_hook = NULL;
+
+	        /* Success */
+	        return (TRUE);
+        }
+    }
+
+#endif /* ALLOW_REPEAT */

 	/* Extract args */
 	if (mode & (USE_EQUIP)) equip = TRUE;
@@ -4049,6 +4100,12 @@

 	/* Warning if needed */
 	if (oops && str) msg_print(str);
+
+#ifdef ALLOW_REPEAT /* TNB */
+
+    if (item) repeat_push(*cp);
+
+#endif /* ALLOW_REPEAT */

 	/* Result */
 	return (item);
diff -u src-orig/store.c src/store.c
--- src-orig/store.c	Wed Feb 11 03:30:30 1998
+++ src/store.c	Mon Feb 16 17:33:42 1998
@@ -1586,6 +1586,20 @@

 	object_type *o_ptr;

+#ifdef ALLOW_REPEAT /* TNB */
+
+    /* Get the item index */
+    if (repeat_pull(com_val)) {
+
+        /* Verify the item */
+        if ((*com_val >= 0) && (*com_val <= (st_ptr->stock_num - 1))) {
+
+	        /* Success */
+	        return (TRUE);
+        }
+    }
+
+#endif /* TNB */

 	/* Assume failure */
 	*com_val = (-1);
@@ -1652,6 +1666,12 @@
 	/* Save item */
 	(*com_val) = item;

+#ifdef ALLOW_REPEAT /* TNB */
+
+	repeat_push(*com_val);
+
+#endif /* ALLOW_REPEAT */
+
 	/* Success */
 	return (TRUE);
 }
@@ -2808,6 +2828,13 @@
  */
 static void store_process_command(void)
 {
+#ifdef ALLOW_REPEAT /* TNB */
+
+    /* Handle repeating the last command */
+    repeat_check();
+
+#endif /* ALLOW_REPEAT */
+
 	/* Parse the command */
 	switch (p_ptr->command_cmd)
 	{
diff -u src-orig/tables.c src/tables.c
--- src-orig/tables.c	Wed Feb 11 03:30:30 1998
+++ src/tables.c	Sun Feb 22 18:04:38 1998
@@ -2601,7 +2601,11 @@
 	"verify_destroy",			/* OPT_verify_destroy */
 	"verify_special",			/* OPT_verify_special */
 	"allow_quantity",			/* OPT_allow_quantity */
+#ifdef ALLOW_EASY_OPEN /* TNB */
+	"easy_open",   /* OPT_easy_open */
+#else
 	NULL,						/* xxx */
+#endif /* ALLOW_EASY_OPEN */
 	"auto_haggle",				/* OPT_auto_haggle */
 	"auto_scum",				/* OPT_auto_scum */
 	"testing_stack",			/* OPT_testing_stack */
@@ -2614,7 +2618,11 @@
 	"dungeon_stair",			/* OPT_dungeon_stair */
 	"flow_by_sound",			/* OPT_flow_by_sound */
 	"flow_by_smell",			/* OPT_flow_by_smell */
+#ifdef ALLOW_EASY_DISARM /* TNB */
+	"easy_disarm",   /* OPT_easy_disarm */
+#else
 	NULL,						/* xxx track_follow */
+#endif /* ALLOW_EASY_DISARM */
 	NULL,						/* xxx track_target */
 	"smart_learn",				/* OPT_smart_learn */
 	"smart_cheat",				/* OPT_smart_cheat */
@@ -2673,7 +2681,11 @@
 	"Verify destruction of objects",			/* OPT_verify_destroy */
 	"Verify use of special commands",			/* OPT_verify_special */
 	"Allow quantity specification",				/* OPT_allow_quantity */
+#ifdef ALLOW_EASY_OPEN /* TNB */
+	"Open and close automatically",   /* OPT_easy_open */
+#else
 	NULL,										/* xxx */
+#endif /* ALLOW_EASY_OPEN */
 	"Auto-haggle in stores",					/* OPT_auto_haggle */
 	"Auto-scum for good levels",				/* OPT_auto_scum */
 	"Allow objects to stack on floor",			/* OPT_testing_stack */
@@ -2686,7 +2698,11 @@
 	"Generate dungeons with connected stairs",	/* OPT_dungeon_stair */
 	"Monsters chase current location (v.slow)",	/* OPT_flow_by_sound */
 	"Monsters chase recent locations (v.slow)",	/* OPT_flow_by_smell */
+#ifdef ALLOW_EASY_OPEN /* TNB */
+	"Disarm traps automatically",   /* OPT_easy_disarm */
+#else
 	NULL,										/* xxx */
+#endif /* ALLOW_EASY_DISARM */
 	NULL,										/* xxx */
 	"Monsters learn from their mistakes",		/* OPT_smart_learn */
 	"Monsters exploit players weaknesses",		/* OPT_smart_cheat */
@@ -2745,7 +2761,11 @@
 	TRUE,		/* OPT_verify_destroy */
 	TRUE,		/* OPT_verify_special */
 	TRUE,		/* OPT_allow_quantity */
+#ifdef ALLOW_EASY_OPEN /* TNB */
+	TRUE,   /* OPT_easy_open */
+#else
 	FALSE,		/* xxx */
+#endif /* ALLOW_EASY_OPEN */
 	TRUE,		/* OPT_auto_haggle */
 	FALSE,		/* OPT_auto_scum */
 	FALSE,		/* OPT_testing_stack */
@@ -2758,7 +2778,11 @@
 	TRUE,		/* OPT_dungeon_stair */
 	FALSE,		/* OPT_flow_by_sound */
 	FALSE,		/* OPT_flow_by_smell */
+#ifdef ALLOW_EASY_DISARM /* TNB */
+	TRUE,   /* OPT_easy_disarm */
+#else
 	FALSE,		/* xxx */
+#endif /* ALLOW_EASY_DISARM */
 	FALSE,		/* xxx */
 	FALSE,		/* OPT_smart_learn */
 	FALSE,		/* OPT_smart_cheat */
@@ -2866,8 +2890,16 @@
 		OPT_view_bright_lite,
 		OPT_view_granite_lite,
 		OPT_view_special_lite,
+#ifdef ALLOW_EASY_OPEN /* TNB */
+		OPT_easy_open,
+#else
 		255,
+#endif /* ALLOW_EASY_OPEN */
+#ifdef ALLOW_EASY_DISARM /* TNB */
+		OPT_easy_disarm,
+#else
 		255
+#endif /* ALLOW_EASY_DISARM */
 	}
 };

diff -u src-orig/util.c src/util.c
--- src-orig/util.c	Wed Feb 11 03:30:30 1998
+++ src/util.c	Mon Feb 16 17:51:48 1998
@@ -561,7 +561,7 @@
 #if defined(MACINTOSH) || defined(WINDOWS)

 	/* Create the file, fail if exists, write-only, binary */
-	return (open(buf, O_CREAT | O_EXCL | O_WRONLY | O_BINARY));
+	return (open(buf, O_CREAT | O_EXCL | O_WRONLY | O_BINARY, mode /* TNB */));

 #else

@@ -2743,6 +2743,14 @@
 		p_ptr->command_arg = 0;
 	}

+#ifdef ALLOW_REPEAT /* TNB */
+
+    /* Get the item index */
+    else if ((max != 1) && allow_quantity && repeat_pull(&amt)) {
+	}
+
+#endif /* ALLOW_REPEAT */
+
 	/* Prompt if needed */
 	else if ((max != 1) && allow_quantity)
 	{
@@ -2779,6 +2787,12 @@
 	/* Enforce the minimum */
 	if (amt < 0) amt = 0;

+#ifdef ALLOW_REPEAT /* TNB */
+
+    if (amt) repeat_push(amt);
+
+#endif /* ALLOW_REPEAT */
+
 	/* Return the result */
 	return (amt);
 }
@@ -3290,4 +3304,80 @@
 #endif


+#ifdef ALLOW_REPEAT /* TNB */
+
+#define REPEAT_MAX		20
+
+/* Number of chars saved */
+static int repeat__cnt = 0;
+
+/* Current index */
+static int repeat__idx = 0;
+
+/* Saved "stuff" */
+static int repeat__key[REPEAT_MAX];
+
+void repeat_push(int what)
+{
+	/* Too many keys */
+	if (repeat__cnt == REPEAT_MAX) return;
+
+	/* Push the "stuff" */
+	repeat__key[repeat__cnt++] = what;
+
+	/* Prevents us from pulling keys */
+	++repeat__idx;
+}
+
+bool repeat_pull(int *what)
+{
+	/* All out of keys */
+	if (repeat__idx == repeat__cnt) return (FALSE);
+
+	/* Grab the next key, advance */
+	*what = repeat__key[repeat__idx++];
+
+	/* Success */
+	return (TRUE);
+}
+
+void repeat_check(void)
+{
+	int		what;
+
+    /* Ignore some commands */
+    if (p_ptr->command_cmd == ESCAPE) return;
+    if (p_ptr->command_cmd == ' ') return;
+    if (p_ptr->command_cmd == '\r') return;
+    if (p_ptr->command_cmd == '\n') return;
+
+	/* Repeat Last Command */
+	if (p_ptr->command_cmd == 'n') {
+
+		/* Reset */
+		repeat__idx = 0;
+
+		/* Get the command */
+		if (repeat_pull(&what)) {
+
+			/* Save the command */
+			p_ptr->command_cmd = what;
+		}
+	}
+
+	/* Start saving new command */
+	else {
+
+		/* Reset */
+		repeat__cnt = 0;
+		repeat__idx = 0;
+
+		what = p_ptr->command_cmd;
+
+		/* Save this command */
+		repeat_push(what);
+	}
+}
+
+#endif /* ALLOW_REPEAT */

diff -u src-orig/xtra2.c src/xtra2.c
--- src-orig/xtra2.c	Wed Feb 11 03:30:30 1998
+++ src/xtra2.c	Mon Feb 16 17:21:18 1998
@@ -3510,6 +3510,17 @@

 	cptr p;

+#ifdef ALLOW_REPEAT /* TNB */
+
+    if (repeat_pull(dp)) {
+
+    	/* Verify */
+    	if (!(*dp == 5 && !target_okay())) {
+	        return (TRUE);
+	    }
+    }
+
+#endif /* ALLOW_REPEAT */

 	/* Initialize */
 	(*dp) = 0;
@@ -3590,6 +3601,12 @@
 	/* Save direction */
 	(*dp) = dir;

+#ifdef ALLOW_REPEAT /* TNB */
+
+    repeat_push(dir);
+
+#endif /* ALLOW_REPEAT */
+
 	/* A "valid" direction was entered */
 	return (TRUE);
 }
@@ -3619,6 +3636,13 @@

 	cptr p;

+#ifdef ALLOW_REPEAT /* TNB */
+
+    if (repeat_pull(dp)) {
+        return (TRUE);
+    }
+
+#endif /* ALLOW_REPEAT */

 	/* Initialize */
 	(*dp) = 0;
@@ -3650,6 +3674,12 @@

 	/* Save direction */
 	(*dp) = dir;
+
+#ifdef ALLOW_REPEAT /* TNB */
+
+    repeat_push(dir);
+
+#endif /* ALLOW_REPEAT */

 	/* Success */
 	return (TRUE);

