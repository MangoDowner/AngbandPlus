/* Copyright (C) 2003-2004 Neil Stevens <neil@hakubi.us>
 // Copyright (C) 2004 Ethan Stump <estump@seas.upenn.edu>
 //
 // Permission is hereby granted, free of charge, to any person obtaining a copy
 // of this software and associated documentation files (the "Software"), to deal
 // in the Software without restriction, including without limitation the rights
 // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 // copies of the Software, and to permit persons to whom the Software is
 // furnished to do so, subject to the following conditions:
 //
 // The above copyright notice and this permission notice shall be included in
 // all copies or substantial portions of the Software.
 //
 // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 // THE AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 // AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 // CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 //
 // Except as contained in this notice, the name(s) of the author(s) shall not be
 // used in advertising or otherwise to promote the sale, use or other dealings
 // in this Software without prior written authorization from the author(s).
 */

#ifdef USE_SDL

#include "angband.h"
#include <SDL.h>
#include <SDL_image.h>
#include <SDL_ttf.h>

#include <math.h>


/*************************************************
 GLOBAL SDL-ToME PROPERTIES
 *************************************************/

/* Default window properties - used if none are available
from other places*/
#define DEF_SCREEN_WIDTH  800
#define DEF_SCREEN_HEIGHT 600
#define DEF_SCREEN_BPP     16

/*Main window properties that may be loaded at runtime from
a preference file or environmental variables. However,
default values (defined above) can be used. */
static int arg_width = DEF_SCREEN_WIDTH;
static int arg_height = DEF_SCREEN_HEIGHT;
static int arg_bpp = DEF_SCREEN_BPP;

/**************/

/* Default font properties - used unless otherwise changed.
These properties are the size and also default font to load. */
#define DEF_FONT_SIZE 14
#define DEF_FONT_FILE "VeraMono.ttf"

/* The font properties that may perhaps be changed at runtime,
due to environmental variables, preference files, or in-program
commands.*/
static int arg_font_size = DEF_FONT_SIZE;
static char arg_font_name[64] = DEF_FONT_FILE;

/**************/

/* The number of term_data structures to set aside mem for */
#define MAX_CONSOLE_COUNT 8

/* The number of consoles that are actually being used.
This number could be changed via preference files, environmental
variables, command-line arguments, or possibly even in-game
keypresses or menu-selections. */
static int arg_console_count = 1;

/* When rendering multiple terminals, each is drawn with a
surrounding border. These values control the width of this
border and also the color to use when drawing it. */
#define BORDER_THICKNESS 1
static int border_color = 0;

/**************/

/* some miscellaneous settings which have not been dealt
with yet */
static bool arg_old_graphics = FALSE;
static bool arg_double_width = FALSE;

/* not dealt with yet (although full screen toggle
is available using Alt-Enter) */
static bool arg_full_screen = FALSE;

/* a flag to show whether window properties have been
set or not... if so, the properties can be dumped
upon quit*/
static bool window_properties_set = FALSE;

/*************************************************
 GLOBAL SDL-ToME VARIABLES
 *************************************************/

/* the main screen to draw to */
static SDL_Surface *screen;

/* some helper surfaces that are used for rendering
characters */
static SDL_Surface *worksurf;
static SDL_Surface *crayon;

/* the cursor surface */
static SDL_Surface *cursor = NULL;

/* the array of pre-rendered characters
(see loadAndRenderFont() below) */
SDL_Surface *text[128];

/* the actual TTF_Font used (XXX should get rid of this)*/
TTF_Font *font=0;

/* the width and height of the uniformly-sized pre-rendered
characters */
int t_width = 0, t_height = 0;


/*************************************************
 COLOR SETUP
 *************************************************/
 
/* A few simple colors, mapped using the format of the main screen */
int screen_black, screen_white, screen_purple;

/* The color to use for the cursor */
static int cursor_color = 0;
/* default cursor color is a semi-transparent yellow */
#define DEF_CURSOR_COLOR	255,255,0,128

/* The array of colors, mapped to the format of the crayon surface,
since this is ultimately the surface that color is begin applied to */
static int color_data[16];

/* The following macro is for color defining...
 Note that the color is fully opaque... */
#define COLOR(r,g,b) \
	SDL_MapRGBA(crayon->format,r,g,b,SDL_ALPHA_OPAQUE)

/*These color macros will setup the colors to use, but must be called after
 the SDL video has been set. That way SDL can correct for any funky video
 setttings. */

#define BLACK			COLOR(  0,  0,  0)	/* 0*/
#define WHITE			COLOR(255,255,255)	/* 1*/
#define MID_GREY		COLOR(128,128,128)	/* 2*/
#define BRIGHT_ORANGE	COLOR(255,128,  0)	/* 3*/
#define RED				COLOR(192,  0,  0)	/* 4*/
#define GREEN			COLOR(  0,128, 64)	/* 5*/
#define BRIGHT_BLUE		COLOR(  0,  0,255)	/* 6*/
#define DARK_ORANGE		COLOR(128, 64,  0)	/* 7*/
#define DARK_GREY		COLOR( 64, 64, 64)	/* 8*/
#define BRIGHT_GREY		COLOR(192,192,192)	/* 9*/
#define PURPLE			COLOR(255,  0,255)	/*10*/
#define YELLOW			COLOR(255,255,  0)	/*11*/
#define BRIGHT_RED		COLOR(255,  0,  0)	/*12*/
#define BRIGHT_GREEN	COLOR(  0,255,  0)	/*13*/
#define AQUAMARINE		COLOR(  0,255,255)	/*14*/
#define BROWN			COLOR(192,128, 64)	/*15*/

/*************************************************
 TERMINAL DATA STRUCTURE SETUP
 *************************************************/

/* Forward declare */
typedef struct _term_data term_data;

/* A structure for each "term" */
struct _term_data
{
	term t;					/* the term structure, defined in z-term.h */
	cptr name;				/* name of this term sub-window */

	uint rows, cols;		/* row/column count */
	uint pos_x, pos_y;		/* upper left corner of rendering box */
	uint size_w, size_h;	/* width, height of rendering box */

	bool has_border;		/* whether this sub-window has a border or not */
	uint border_thick;		/* thickness of border to draw around window */
	
	uint tile_width;		/* the width of each tile (graphic or otherwise)*/
	uint tile_height;		/* the height of each tile (graphic or otherwise)*/
	
#ifdef USE_GRAPHICS
#ifdef USE_TRANSPARENCY
#endif
#endif
};

/* The array of term data structures */
static term_data data[MAX_CONSOLE_COUNT];

/*************************************************
 FILE-SPECIFIC MACROS
 *************************************************/

/* Debug macros! */
#define DB(str) \
	printf("main-sdl: %s\n",str);

/* Prints out the RGBA values of a given color */
#define TYPECOLOR32(color) 	printf("  R:%d\tG:%d\tB:%d\tA:%d\t\n",\
	color>>24,(color&0x00ff0000)>>16,\
	(color&0x0000ff00)>>8,(color&0x000000ff))

#define TYPECOLOR16(color) 	printf("  R:%d\tG:%d\tB:%d\tA:%d\t\n",\
	(color&0xf000)>>12,(color&0x0f00)>>8,\
	(color&0x00f0)>>4,(color&0x000f))

/* SDL Surface locking and unlocking */
#define SDL_LOCK(surf) \
	if (SDL_MUSTLOCK(surf) ){ \
		if (SDL_LockSurface(surf) < 0) { \
			printf("Can't lock the screen: %s\n", SDL_GetError()); \
			exit(1); \
		} \
	}

#define SDL_UNLOCK(surf) \
	if (SDL_MUSTLOCK(surf) ){ \
		SDL_UnlockSurface(surf); \
	}

/*************************************************
 QUITTING
 *************************************************/

/* function prototype */
void dumpWindowSettings(void);
	
/* SDL Quitting function... declare a few functions first.*/
void killFontAndAlphabet(void);
static void sdl_quit(cptr string)
{
	printf("sdl_quit called.\n");
	printf("message: %s\n",string);
	/* Need to take care of font and rendered characters */
	killFontAndAlphabet();
	if (TTF_WasInit())
		TTF_Quit();
	/* Then exit SDL */
	SDL_Quit();
	
	/* Dump the window properties, if available */
	if (window_properties_set)
		dumpWindowSettings();
	
	/* And now for the default quit behavior */
	quit_aux = 0;
	quit(string);
}

/*************************************************
 FONT SUPPORT FUNCTIONS
 *************************************************/

/* killFontAndAlphabet will effectively de-initialize the font system;
it does this by closing the font and destroying any pre-rendered
text in memory */
void killFontAndAlphabet(void)
{
	int i;
	/* need to close a font and free all of its corresponding pre-rendered
	surfaces */
	if (font)
	{
		TTF_CloseFont(font);
		font = 0;
	}
	for (i=0;i<128;i++)
	{
		if(text[i])
		{
			SDL_FreeSurface(text[i]);
			text[i] = NULL;
		}
	}
}

/* loadAndRenderFont is responsible for loading and initializing
a font. First, SDL_ttf calls are made to load and set the style
for the desired font. Next, a character alphabet is rendered and
each character is placed onto a uniformly-sized surface within
the text[] array. Whenever text is needed for displaying on-screen,
this array is referenced and the desired character picture is used. */
void loadAndRenderFont(char *fname, int size)
{
	int minx,maxx,miny,maxy,advance,i,midline = 0;
	char filename[PATH_MAX + 1];
	char fontdir[PATH_MAX + 1];
	SDL_Color base_color = {255,255,255,255};
	SDL_Surface *temp_surf;
	SDL_Rect tgt = {0,0,0,0};


	/* Assuming that the filename is valid,open the font */
	path_build(fontdir, PATH_MAX, ANGBAND_DIR_XTRA, "font");
	path_build(filename, PATH_MAX, fontdir, fname);
	font = TTF_OpenFont(filename,size);
	if (font == NULL)
		sdl_quit("Error loading that font!");
	/* Set the font style to normal */
	TTF_SetFontStyle(font,TTF_STYLE_NORMAL);

	/* Collect some measurements on this font -
	arbitrarily choose the letter 'a' to get width*/
	TTF_GlyphMetrics(font,'a',&minx,&maxx,&miny,&maxy,&advance);
	/* the width of each character tile */
	t_width = advance;
	/* the height of each character tile */
	t_height = TTF_FontHeight(font);
	/* position of the y=0 line in each tile */
	midline = TTF_FontAscent(font);

	/* now... render each of the individual characters */
	for (i=0;i<128;i++)
	{
		/* make a pretty blended glyph */
		temp_surf=TTF_RenderGlyph_Blended(font,i,base_color);
		/* and make sure that we got it right! */
		if (temp_surf == NULL)
			sdl_quit("Glyph failed to render!");
		/* get the metrics of this particular glyph so we can position it */
		TTF_GlyphMetrics(font,i,&minx,&maxx,&miny,&maxy,&advance);
		/* copy rendered glyph into text queue, at the right position*/
		tgt.x = minx;
		tgt.y = midline-maxy;
		/* but first... we'll need a surface in the text queue to blit to! */
		text[i] = SDL_CreateRGBSurface(SDL_HWSURFACE,t_width,\
			t_height,16,0xf000,0x0f00,0x00f0,0x000f);
		/* turn OFF src-alpha... results in brute
		 copy of the RGBA contents of surf */
		SDL_SetAlpha(temp_surf,0,0);
		SDL_BlitSurface(temp_surf,NULL,text[i],&tgt);
		/* turn OFF src-alpha since we'll be using worksurf for blitting */
		SDL_SetAlpha(text[i],0,0);
		/* kill the surface to patch up memory leaks */
		SDL_FreeSurface(temp_surf);
	}
}

/***********************************************/

/*** Function hooks needed by "Term" ***/

static void Term_init_sdl(term *t)
{
	term_data *td = (term_data*)(t->data);
	DB("Term_init_sdl");
	/* XXX XXX XXX */
}

static void Term_nuke_sdl(term *t)
{
	term_data *td = (term_data*)(t->data);
	DB("Term_nuke_sdl");
	/* XXX XXX XXX */
}

static errr Term_user_sdl(int n)
{
	term_data *td = (term_data*)(Term->data);
	DB("Term_user_sdl");
	/* XXX XXX XXX */

	/* Unknown */
	return (1);
}

/* KEYPRESS_STRING repeatedly sends characters to the terminal
XXX - should implement routine from maim-sdl.c, it's sooo much
cleaner */
#define KEYPRESS_STRING(str) \
strcpy(buf,str); \
n = buf; \
while (*n != '\0') { \
	Term_keypress((int)(*(n++))); \
}

/* function prototype */
void manipulationMode(void);

/* This is the main event handling routine that will be called
whenever an event is pulled off of the queue (in Term_xtra_sdl())*/
void handleEvent(SDL_Event *event)
{
	static char buf[24];	/* a buffer used when passing key names */
	char *n;				/* and a pointer to manipulate this buffer */

	switch( event->type )
	{
	case SDL_KEYDOWN:
		{
			/* handle key presses */

			/* I'm reading that as long as the upper 9 bits of the unicode
			 * value are zero, then the lower 7 bits are direct ASCII characters.
			 * Furthermore, it seems that all basic keys return non-zero values
			 * for the lower 7 bits, but function keys and other various things
			 * return 0000000 for the lower 7 bits.
			 * Basically, if the lower 7 bits are zero, do something special
			 *  (like start a macro), but otherwise just pass along the ASCII
			 * code!
			 */
			byte ascii_part = event->key.keysym.unicode & 0x00ff;

			/* gimme the key name */
			printf("Key is: %s\n",SDL_GetKeyName(event->key.keysym.sym));

			/* allow for full screen toggling! */
			if ((event->key.keysym.sym == SDLK_RETURN) && \
				(SDL_GetModState() & KMOD_ALT))
			{
				SDL_WM_ToggleFullScreen(screen);
			}

			/* entry into window manipulation mode */
			if ((event->key.keysym.sym == SDLK_RETURN) && \
				(SDL_GetModState() & KMOD_CTRL))
			{
				DB("Manipulation mode!");
				manipulationMode();
			}
			
			/*printf("ascii_part: %d\n",ascii_part);*/
			if (ascii_part)
			{
				/* We have now determined that the ASCII part is not '0', so
				 we can safely pass along the ASCII value! */
				Term_keypress(ascii_part);
			}
			else
			{
				/* We want to ignore keypresses that are simply the modifier
				keys*/
				if (!( (event->key.keysym.sym == SDLK_RSHIFT) |
					(event->key.keysym.sym == SDLK_LSHIFT) |
					(event->key.keysym.sym == SDLK_RALT) |
					(event->key.keysym.sym == SDLK_LALT) |
					(event->key.keysym.sym == SDLK_RCTRL) |
					(event->key.keysym.sym == SDLK_LCTRL) ))
				{

					/* now build a macro string using the modifiers together
					with the key that was just pressed*/

					/* As for the formatting...
					 * We pass the key press and modifiers as follows:
					 * \[ctrl-alt-shift-"key name"]
					 * following the previously established convention...
					 *
					 * All of the things that happen are defined in pref-sdl.prf
					 */

					KEYPRESS_STRING("\[");	/*Output the first part... */
					/* See if a control key is down */
					if (event->key.keysym.mod & KMOD_CTRL)
					{
						KEYPRESS_STRING("ctrl-");
					}
					/* See if an alt key is down */
					if (event->key.keysym.mod & KMOD_ALT)
					{
						KEYPRESS_STRING("alt-");
					}
					/* See if a shift key is down */
					if (event->key.keysym.mod & KMOD_SHIFT)
					{
						KEYPRESS_STRING("shift-");
					}

					/* Add in the name of whatever key was pressed */
					KEYPRESS_STRING(SDL_GetKeyName(event->key.keysym.sym));

					/* and end it... */
					KEYPRESS_STRING("]");
				}
			}
			break;
		}
	case SDL_QUIT:
		{
			/* handle quit requests */
			sdl_quit("Quitting!\n");
			break;
		}
	default:
		{
			break;
		}
	}
}

/* declare the screen clearing function used below */
void eraseTerminal(bool draw_borders);
static errr Term_xtra_sdl(int n, int v)
{
	static SDL_Event event;
	term_data *td;

	/* Analyze */
	switch (n)
	{
	case TERM_XTRA_EVENT:
		{
			if (v)
			{
				/* Perform event checking with blocking */
				SDL_WaitEvent( &event );
				handleEvent( &event );
			} else {
				/* Perform event checking without blocking */
				if (SDL_PollEvent(&event)){
					/* We found an event! */
					handleEvent(&event);
				}
			}
			return(0);
		}

	case TERM_XTRA_FLUSH:
		{
			/* Keep doing events until the queue is empty! */
			while (SDL_PollEvent(&event))
			{
				handleEvent(&event);
			}
			return (0);
		}

	case TERM_XTRA_CLEAR:
		{
			/* Clear the terminal and redraw the borders */
			eraseTerminal(TRUE);
			return (0);
		}

	case TERM_XTRA_SHAPE:
		{
			/*
			 * Set the cursor visibility XXX XXX XXX
			 *
			 * This action should change the visibility of the cursor,
			 * if possible, to the requested value (0=off, 1=on)
			 *
			 * This action is optional, but can improve both the
			 * efficiency (and attractiveness) of the program.
			 */

			return (0);
		}

	case TERM_XTRA_FROSH:
		{
			/*
			 * Flush a row of output XXX XXX XXX
			 *
			 * This action should make sure that row "v" of the "output"
			 * to the window will actually appear on the window.
			 *
			 * This action is optional, assuming that "Term_text_xxx()"
			 * (and similar functions) draw directly to the screen, or
			 * that the "TERM_XTRA_FRESH" entry below takes care of any
			 * necessary flushing issues.
			 */

			return (1);
		}

	case TERM_XTRA_FRESH:
		{
			/*
			 * Flush output XXX XXX XXX
			 *
			 * This action should make sure that all "output" to the
			 * window will actually appear on the window.
			 *
			 * This action is optional, assuming that "Term_text_xxx()"
			 * (and similar functions) draw directly to the screen, or
			 * that the "TERM_XTRA_FROSH" entry above takes care of any
			 * necessary flushing issues.
			 */

			return (1);
		}

	case TERM_XTRA_NOISE:
		{
			/*
			 * Make a noise XXX XXX XXX
			 *
			 * This action should produce a "beep" noise.
			 *
			 * This action is optional, but convenient.
			 */

			return (1);
		}

	case TERM_XTRA_SOUND:
		{
			/*
			 * Make a sound XXX XXX XXX
			 *
			 * This action should produce sound number "v", where the
			 * "name" of that sound is "sound_names[v]".  This method
			 * is still under construction.
			 *
			 * This action is optional, and not very important.
			 */

			return (1);
		}

	case TERM_XTRA_BORED:
		{
			/* Perform event checking without blocking */
			if (SDL_PollEvent(&event)){
				/* We found an event! */
				handleEvent(&event);
			}
			return(0);
		}

	case TERM_XTRA_REACT:
		{
			/*
			 * React to global changes XXX XXX XXX
			 *
			 * For example, this action can be used to react to
			 * changes in the global "color_table[256][4]" array.
			 *
			 * This action is optional, but can be very useful for
			 * handling "color changes" and the "arg_sound" and/or
			 * "arg_graphics" options.
			 */

			return (1);
		}

	case TERM_XTRA_ALIVE:
		{
			/*
			 * Change the "hard" level XXX XXX XXX
			 *
			 * This action is used if the program changes "aliveness"
			 * by being either "suspended" (v=0) or "resumed" (v=1)
			 * This action is optional, unless the computer uses the
			 * same "physical screen" for multiple programs, in which
			 * case this action should clean up to let other programs
			 * use the screen, or resume from such a cleaned up state.
			 *
			 * This action is currently only used by "main-gcu.c",
			 * on UNIX machines, to allow proper "suspending".
			 */

			return (1);
		}

	case TERM_XTRA_LEVEL:
		{
			/*
			 * Change the "soft" level XXX XXX XXX
			 *
			 * This action is used when the term window changes "activation"
			 * either by becoming "inactive" (v=0) or "active" (v=1)
			 *
			 * This action can be used to do things like activate the proper
			 * font / drawing mode for the newly active term window.  This
			 * action should NOT change which window has the "focus", which
			 * window is "raised", or anything like that.
			 *
			 * This action is optional if all the other things which depend
			 * on what term is active handle activation themself, or if only
			 * one "term_data" structure is supported by this file.
			 */

			return (1);
		}

	case TERM_XTRA_DELAY:
		{
			/*
			 * Delay for some milliseconds XXX XXX XXX
			 *
			 * This action is useful for proper "timing" of certain
			 * visual effects, such as breath attacks.
			 *
			 * This action is optional, but may be required by this file,
			 * especially if special "macro sequences" must be supported.
			 */

			/* I think that this command is system independent... */
			/*sleep(v/1000);*/
			/* main-x11 uses usleep(1000*v); */
			/* main-win uses Sleep(v); */
			return (1);
		}

	case TERM_XTRA_GET_DELAY:
		{
			/*
			 * Get Delay of some milliseconds XXX XXX XXX
			 * place the result in Term_xtra_long
			 *
			 * This action is useful for proper "timing" of certain
			 * visual effects, such as recording cmovies.
			 *
			 * This action is optional, but cmovies wont perform
			 * good without it
			 */

			return (1);
		}
	}

	/* Unknown or Unhandled action */
	return (1);
}

/*************************************************
 GRAPHICS ROUTINES
 *************************************************/

/* utility routine for creating and setting the color of the cursor;
it could be useful for setting a new cursor color if desired.
Could later be expanded to do other stuff with the cursor,
like a hollow rectangle a la main-win.c or even a graphic */
void createCursor(byte r, byte g, byte b, byte a)
{
	/* free the cursor if it exists */
	if (cursor != NULL)
		SDL_FreeSurface(cursor);
	/* and create it anew! (or the first time) */
	cursor = SDL_CreateRGBSurface(SDL_HWSURFACE,t_width,\
		t_height,16,0xf000,0x0f00,0x00f0,0x000f);
	/* be sure to use alpha channel when blitting! */
	SDL_SetAlpha(cursor,SDL_SRCALPHA,0);
	
	/* just set the color for now - drawing rectangles
	needs surface locking for some setups */
	cursor_color = SDL_MapRGBA(cursor->format,r,g,b,a);
	SDL_LOCK(cursor);
	SDL_FillRect(cursor,NULL,cursor_color);
	SDL_UNLOCK(cursor);
}

/* Cursor Display routine - just blits the global cursor
surface onto the correct location */
static errr Term_curs_sdl(int x, int y)
{
	term_data *td = (term_data*)(Term->data);
	static SDL_Rect base;

	/* calculate the position to place the cursor */
	base.x = td->pos_x + x*t_width;
	base.y = td->pos_y + y*t_height;
	base.w = t_width;
	base.h = t_height;
	
	/* blit the cursor over top of the given spot;
	note that surface should not be locked
	(see note in Term_text_sdl() below) */
	SDL_BlitSurface(cursor,NULL,screen,&base);

	// And... UPDATE the cursor spot!
	SDL_UpdateRects(screen,1,&base);
	
	/* Success */
	return (0);
}

/* routine for wiping terminal locations - simply draws
a black rectangle over the offending spots! */
static errr Term_wipe_sdl(int x, int y, int n)
{
	static SDL_Rect base;
	term_data *td = (term_data*)(Term->data);

	/* calculate boundaries of the area to clear */
	base.x = td->pos_x + x*t_width;
	base.y = td->pos_y + y*t_height;
	base.w = n*t_width;
	base.h = t_height;

	SDL_LOCK(screen);
	
	/* blank the screen area */
	SDL_FillRect(screen, &base, screen_black);

	SDL_UNLOCK(screen);

	/* And... UPDATE the rectangle we just wrote to! */
	SDL_UpdateRects(screen,1,&base);

	/* Success */
	return (0);
}
	
/* Perform a full clear of active terminal; redraw the borders.*/
void eraseTerminal(bool draw_borders)
{
	static SDL_Rect base, bordered_base;
	term_data *td = (term_data*)(Term->data);
	
	/* get the rectangle for the active terminal */
	base.x = td->pos_x;
	base.y = td->pos_y;
	base.w = td->size_w;
	base.h = td->size_h;
	/* be sure to make an oversized rectangle
	for drawing the borders, if enabled */
	if (td->has_border)
	{
		 bordered_base.x = base.x - td->border_thick;
		 bordered_base.y = base.y - td->border_thick;
		 bordered_base.w = base.w + 2*td->border_thick;
		 bordered_base.h = base.h + 2*td->border_thick;
	}

	SDL_LOCK(screen);
	
	/* now draw this terminal's border;
	if draw_borders is selected, then draw with the global
	border_color value... however, if draw_borders is NOT
	selected, then the desirable thing to do is just
	black out everything, to erase the existing borders
	that may have been drawn!*/
	if (td->has_border)
	{
		if (draw_borders)
		{
			/* Use the enlarged bordered_base rectangle */
			/* And color it with given border color */
			SDL_FillRect(screen, &bordered_base, border_color);
		}
		else
		{
			SDL_FillRect(screen, &bordered_base, screen_black);
		}
	}

	/* now draw the main terminal part, effectively subtracting
	the middle out of the previous rectangle if borders are
	enabled  - ignore the fact that this part may have already
	been blacked out above! */
	SDL_FillRect(screen, &base, screen_black);

	SDL_UNLOCK(screen);

	/* And... UPDATE the changed part */
	if (td->has_border)
	{
		SDL_UpdateRects(screen, 1, &bordered_base);
	}
	else
	{
		SDL_UpdateRects(screen, 1, &base);
	}
}

/*
 * Draw some text on the screen
 *
 * This function should actually display an array of characters
 * starting at the given location, using the given "attribute",
 * and using the given string of characters, which contains
 * exactly "n" characters and which is NOT null-terminated.
 *
 * You may assume "valid" input if the window is properly sized.
 *
 * You must be sure that the string, when written, erases anything
 * (including any visual cursor) that used to be where the text is
 * drawn.  On many machines this happens automatically, on others,
 * you must first call "Term_wipe_xxx()" to clear the area.
 *
 * In color environments, you should activate the color contained
 * in "color_data[a & 0x0F]", if needed, before drawing anything.
 *
 * You may ignore the "attribute" if you are only supporting a
 * monochrome environment, since this routine is normally never
 * called to display "black" (invisible) text, including the
 * default "spaces", and all other colors should be drawn in
 * the "normal" color in a monochrome environment.
 *
 * Note that if you have changed the "attr_blank" to something
 * which is not black, then this function must be able to draw
 * the resulting "blank" correctly.
 *
 * Note that this function must correctly handle "black" text if
 * the "always_text" flag is set, if this flag is not set, all the
 * "black" text will be handled by the "Term_wipe_xxx()" hook.
 */
static errr Term_text_sdl(int x, int y, int n, byte a, const char *cp)
{
	term_data *td = (term_data*)(Term->data);
	static SDL_Rect base;
	SDL_Rect base_back;
	int i = n;
	char old = 0;

	/* calculate place to clear off and draw to */
	base.x = td->pos_x + x*t_width;
	base.y = td->pos_y + y*t_height;
	base.w = n*t_width;
	base.h = t_height;

	base_back = base;

	SDL_LOCK(screen);

	/* blank the screen area */
	SDL_FillRect(screen, &base, screen_black);

	SDL_UNLOCK(screen);

	/* Note that SDL docs specify that SDL_BlitSurface should not be called
	 on locked surfaces... since the character printing routine below revolves
	 around blitting, the surface has been unlocked first*/

	/* loop through the input string, drawing characters */
	i = n;
	old = 0;
	while (i--)
	{
		/* Output the character... */
		/* If character has not changed, then just blit the old surface into
		 the new location to save effort*/
		if (*cp == old)
		{
			/* the desired character/color combo is already on the work surf */
			/* just blit it! */
			SDL_BlitSurface(worksurf,NULL,screen,&base);
		} else {
			/* copy the desired character onto working surface */
			SDL_BlitSurface(text[*cp],NULL,worksurf,NULL);
			/* color our crayon surface with the desired color */
			SDL_FillRect(crayon,NULL,color_data[a&0x0f]);
			/* apply the color to the character on the working surface */
			SDL_BlitSurface(crayon,NULL,worksurf,NULL);
			/* and blit it onto our screen! */
			SDL_BlitSurface(worksurf,NULL,screen,&base);
		}
		/* Move to the next position */
		base.x += t_width;
		/* Store the old character */
		old = *cp;
		/* Increment the character pointer */
		cp++;
	}

	// And... UPDATE the rectangle we just wrote to!
	SDL_UpdateRects(screen,1,&base_back);
	/* Success */
	return (0);
}

/*
 * Draw some attr/char pairs on the screen
 *
 * This routine should display the given "n" attr/char pairs at
 * the given location (x,y).  This function is only used if one
 * of the flags "always_pict" or "higher_pict" is defined.
 *
 * You must be sure that the attr/char pairs, when displayed, will
 * erase anything (including any visual cursor) that used to be at
 * the given location.  On many machines this is automatic, but on
 * others, you must first call "Term_wipe_xxx(x, y, 1)".
 *
 * With the "higher_pict" flag, this function can be used to allow
 * the display of "pseudo-graphic" pictures, for example, by using
 * the attr/char pair as an encoded index into a pixmap of special
 * "pictures".
 *
 * With the "always_pict" flag, this function can be used to force
 * every attr/char pair to be drawn by this function, which can be
 * very useful if this file can optimize its own display calls.
 *
 * This function is often associated with the "arg_graphics" flag.
 *
 * This function is only used if one of the "higher_pict" and/or
 * "always_pict" flags are set.
 */
static errr Term_pict_sdl(int x, int y, int n, const byte *ap, const char *cp)
{
	term_data *td = (term_data*)(Term->data);
	DB("Term_pict_sdl");
	/* XXX XXX XXX */

	/* Success */
	return (0);
}

/*************************************************
 SPECIAL TERMINAL WINDOW MANIPULATION ROUTINES
 *************************************************/

/* macro for bounding a value between two given values */
#define BOUND(val,low,high) \
if (val < low) \
{ \
	val = low; \
} \
else if (val > high) \
{ \
	val = high; \
}

/* macro returns the border thickness if td->has_border
is true, otherwise returns 0 */
#define BORDER_SWITCH \
( td->has_border ? td->border_thick : 0 )

/* two macros to get the adjusted maximums for window
positions... eg the screen width minus the width of the
window is the maximum x-position that the window can
be set at. */
#define MAX_X \
( arg_width - td->size_w )

#define MAX_Y \
( arg_height - td->size_h )

/* another two macros that give maximum window widths
based on screen size and current window position together
width tile widths/heights - similar to above but
different :) */
#define MAX_WIDTH \
( (int)floorf((arg_width - BORDER_SWITCH - td->pos_x)/td->tile_width))

#define MAX_HEIGHT \
( (int)floorf((arg_height - BORDER_SWITCH - td->pos_y)/td->tile_height))

/* simply update the width and height of given term by simply
multiplying the tile count by tile size */
#define CALCULATE_SIZE(td) \
	td->size_w = (td->cols)*td->tile_width; \
	td->size_h = (td->rows)*td->tile_height

/* Resize the active terminal with new width and height.
Note that his involves a complicated sequence of events...
Details to follow below! */
void resizeTerminal(int width, int height)
{
	term_data *td = (term_data*)(Term->data);
	
	/* First of all, bound the input width and height to satisfy
	these conditions:
	- The main ToME window should be at least 80 cols, 24 rows
	- no part of each window should be drawn off screen....
	  I'm including borders in this restriction!
	But no bounds checking needs to take place if the input width
	and height are unchanged....
	*/

	if (td == &data[0])
	{
		/* The active terminal is the main ToME window...
		don't let the width get below 80, don't let the heights below
		24, and don't let it leak off of the edge! */
		if (width != td->cols)
		{
			BOUND(width,80,MAX_WIDTH);
		}
		if (height != td->rows)
		{
			BOUND(height,24,MAX_HEIGHT);
		}
	}
	else
	{
		/* This is not the main window... just make sure it
		doesn't shrink to nothing or go past the edge */
		if (width != td->cols)
		{
			BOUND(width,1,MAX_WIDTH);
		}
		if (height != td->rows)
		{
			BOUND(height,1,MAX_HEIGHT);
		}
	}
	
	/* Okay, now make sure that something has ACTUALLY changed 
	before doing anything */
	if ((width != td->cols) || (height != td->rows))
	{
		/* First, blank out the current terminal location,
		so as to prevent a strange drag/warp effect...
		of course, now it will just blank out, but it's okay
		for the time being - don't draw borders, of course */
		eraseTerminal(FALSE);
		
		/* Now, ask zterm to please resize the term structure! */
		Term_resize(width,height);

		/* Reactivate, since Term_resize seems to activate the
		main window again...*/
		Term_activate(&td->t);
		
		/* It might not have resized completely to the new
		size we wanted (some windows have size limits it seems,
		like the message window). So, update our structure with
		the size that were actually obtained.*/
		td->cols = Term->wid;
		td->rows = Term->hgt;
		
		/* And recalculate the sizes */
		CALCULATE_SIZE(td);
		
		/* Reactivate, since Term_resize seems to activate the
		main window again...*/
		Term_activate(&td->t);
		
		/* Now we should be in business for a complete redraw! */
		Term_redraw();
		
		/* That's it! */
	}
}

/* Move the terminal around... a much simpler action that involves
just changing the pos_x/pos_y values and redrawing!*/
void moveTerminal(int x, int y)
{
	term_data *td = (term_data*)(Term->data);
	
	/* Now, the window is being shifted about... much simpler
	situation to handle! But of course, the window must not
	drift too far or else parts will be hanging off the screen
	and may lead to errors - bound the input positions to
	prevent this unfortunate situation... do nothing if the
	input is no different than the current */
	if (x != td->pos_x)
	{
		/*BOUND(x,BORDER_SWITCH,MAX_X); */
		BOUND(x,1,MAX_X);
	}
	if (y != td->pos_y)
	{
		/*BOUND(y,BORDER_SWITCH,MAX_Y); */
		BOUND(y,1,MAX_Y);
	}
	
	/* Okay, now make sure that something changed before doing
	anything */
	if ((x != td->pos_x) || (y != td->pos_y))
	{
		/* First, blank out the current terminal location,
		so as to prevent a strange drag/warp effect...
		of course, now it will just blank out, but it's okay
		for the time being - don't draw borders, of course */
		eraseTerminal(FALSE);
		
		/* Now update OUR structure */
		td->pos_x = x;
		td->pos_y = y;
		
		/* Then do a redraw to see the results */
		Term_redraw();
		
		/* That's it! */
	}
}

/* This utility routine will cycle the active term to the
next available in the data[] array. It will then do a
redraw of this term so that it is ready to be manipulated.
The input is the current active terminal, and the output is
the new active terminal */
int cycleTerminal(int current)
{
	/* redraw the current term to get rid of its purple
	border */
	border_color = screen_white;
	Term_redraw();
	
	/* increment the terminal number*/
	current++;
	/* now do a little modulo cycle action and 
	activate the next term! */
	current %= arg_console_count;
	Term_activate(&(data[current].t));
	
	/* before redrawing, set the border color to purple to
	indicate that this terminal is being manipulated*/
	border_color = screen_purple;
	
	/* and do a complete redraw */
	Term_redraw();
	
	/* return the current terminal... */
	return current;
}
	
/* This utility routine will completely blank the screen and
then cycle through all terminals, performing a Term_redraw()
on each and every term that is being used (according to
arg_term_count that is). The terminals will be redrawn
last-to-first, so that the main is over top of everything */
void redrawAllTerminals(void)
{
	int i = arg_console_count;
	
	/* do a complete screen wipe */
	SDL_LOCK(screen);
	SDL_FillRect(screen,NULL,screen_black);
	SDL_UNLOCK(screen);
	SDL_UpdateRect(screen,0,0,arg_width,arg_height);

	/* before redrawing all the terminals, set the border
	color to the normal color since manipulation is over */
	border_color = screen_white;
	
	/* cycle down through each terminal */
	while (i--)
	{
		/* Activate this terminal */
		Term_activate(&(data[i].t));
		
		/* And redraw it */
		Term_redraw();
	}
	/* Loop will end on i=0 ! */
}

/* This is the special event handling function for doing
terminal window manipulation! When special manipulation
mode is activated, execution goes here. This special mode
has its own keypresses. To begin with, the main terminal
border is highlighted (in purple) to indicate that it is
being manipulated. The following keypresses are accepted:
-Space: switches between editing modes. The system begins
  in position editing mode, and Enter will toggle size
  (row/col) editing mode.
-Arrows: increments/decrements the position/size in an
  intuitive way! ;) Some modifiers are accepted in order
  to speed things up on very high resolution screens:
   . with shift down, increment is five
   . with ctrl down, increment is ten
   . with both, increment is fifty!
  Of course, no movement or resize can cause the window
  to leave the confines of the screen, so using the big
  jump is safe.
-Enter: cycles to the next available terminal to edit.
-Escape: quits manipulation mode, performing one final
  redraw to take into account all changes.
*/
void manipulationMode(void)
{
	term_data *td;
	SDL_Event event;
	bool done = FALSE, moveMode = TRUE;
	int value = 0, delta_x = 0, delta_y = 0;
	int current_term;
	
	/* Begin by redrawing the main terminal with its
	purple border to signify that it is being edited*/

	/* start with the main terminal */
	current_term = 0;
	
	/* get the pointer */
	td = &data[0];
	
	/* before redrawing, set the border color to purple to
	indicate that this terminal is being manipulated*/
	border_color = screen_purple;
	
	/* and do a complete redraw */
	Term_redraw();
	
	/* Now keep looping until Esc has been pressed. */
	while (!done)
	{
		/* Get the keypress event */
		SDL_WaitEvent(&event);
		/* Make sure that it is a keypress */
		if (event.type == SDL_KEYDOWN)
		{
			/* Act on the keypress! */
			switch (event.key.keysym.sym)
			{
				case SDLK_ESCAPE:
				{
					/* Escape has been pressed, so we're done!*/
					done = TRUE;
					break;
				}
				case SDLK_SPACE:
				{
					/* Space has been pressed: toggle move mode */
					moveMode = ( moveMode ? FALSE : TRUE );
					break;
				}
				case SDLK_RETURN:
				{
					/* Return... cycle the terminals!
					update the current_term appropriately*/
					current_term = cycleTerminal(current_term);
					
					/* Get the new term_data */
					td = &data[current_term]
					;
					
					break;
				}
				case SDLK_RIGHT:
				case SDLK_LEFT:
				case SDLK_DOWN:
				case SDLK_UP:
				{
					/* Increase either the x-position or column
					width - multiply according to modifiers */
					value = 1;
					if (SDL_GetModState() & KMOD_SHIFT)
					{
						/* shift is down... a muliplier of 5 */
						value *= 5;
					}
					if (SDL_GetModState() & KMOD_CTRL)
					{
						/* control is down... multiply by 10 */
						value *= 10;
					}
					
					/* Now, behavior depends on which key was pressed
					and whether we are in moveMode resize mode... */
					
					/* First, set the delta_x/y based on key */
					if (event.key.keysym.sym == SDLK_RIGHT)
					{
						delta_x = 1;
						delta_y = 0;
					}
					if (event.key.keysym.sym == SDLK_LEFT)
					{
						delta_x = -1;
						delta_y = 0;
					}
					if (event.key.keysym.sym == SDLK_DOWN)
					{
						delta_x = 0;
						delta_y = 1;
					}
					if (event.key.keysym.sym == SDLK_UP)
					{
						delta_x = 0;
						delta_y = -1;
					}
					
					/* Now either moveTerminal() or 
					resizeTerminal() based on value of
					moveMode! */
					if (moveMode)
					{
						moveTerminal(td->pos_x + value*delta_x,\
							td->pos_y + value*delta_y);
					}
					else
					{
						resizeTerminal(td->cols + value*delta_x,\
							td->rows + value*delta_y);
					}
					break;
				}
				default:
				{
					break;
				}
			}
		}
	}
	/* Perform the last redraw to take all changes
	into account */
	redrawAllTerminals();
}

/*************************************************
 INITIALIZATION ROUTINES
 *************************************************/

static errr term_data_init(term_data *td, int i)
{
	term *t = &(td->t);
	char env_var[80];
	cptr val;

	
	/***** load position, size information */
	
	int cols, rows, x, y;	
	
	/* grab the column and row counts from
	environmental variables for now */
	sprintf(env_var,"TOME_NUM_COLS_%d",i);
	val = getenv(env_var);
	/* make sure it is valid */
	if (val != NULL)
	{
		cols = atoi(val);
		/* now make sure that the main window will
		have at least 80x24 */
		if (td == &data[0])
		{
			/* can't really pick an upper bound without
			knowing what the position is... oh well. */
			BOUND(cols,80,255);
		}
	}
	else
	{
		/* no environmental variable... have to guess
		something. If it's the main window, choose
		the minimum. */
		if (td == &data[0])
			cols = 80;
		else
			cols = 5;
	}
	/* do the rows */
	sprintf(env_var,"TOME_NUM_ROWS_%d",i);
	val = getenv(env_var);
	/* make sure it is valid */
	if (val != NULL)
	{
		rows = atoi(val);
		/* now make sure that the main window will
		have at least 80x24 */
		if (td == &data[0])
		{
			/* can't really pick an upper bound without
			knowing what the position is... oh well. */
			BOUND(rows,24,128);
		}
	}
	else
	{
		/* no environmental variable... have to guess
		something. If it's the main window, choose
		the minimum. */
		if (td == &data[0])
			rows = 24;
		else
			rows = 3;
	}
	/* store these values in the term_data structure */
	td->rows = rows;
	td->cols = cols;
	
	/* the position will be loaded from environmental
	variables as well - for the time being*/
	/* x-location */
	sprintf(env_var,"TOME_X_POS_%d",i);
	val = getenv(env_var);
	/* make sure it is valid */
	if (val != NULL)
	{
		x = atoi(val);
		/* now do intelligent position checking */
		BOUND(x,1,MAX_X);
	}
	else
	{
		/* no variable, choose something */
		x = 20*i;
	}
	/* y-location */
	sprintf(env_var,"TOME_Y_POS_%d",i);
	val = getenv(env_var);
	/* make sure it is valid */
	if (val != NULL)
	{
		y = atoi(val);
		/* position checking again */
		BOUND(y,1,MAX_Y);
	}
	else
	{
		/* no variable */
		y = 20*i;
	}
	/* and store these values into the structure */
	td->pos_x = x;
	td->pos_y = y;
	
	/*********** term structure initializing */
	
	/* Initialize the term */
	// gets: pointer to address, number of columns, number of rows, number
	//   of keypresses to queue up (guess 24?)
	term_init(t, cols, rows, 24);

	/* Use a "soft" cursor */
	t->soft_cursor = TRUE;

	// Picture routine flags
	t->always_pict = FALSE;
	t->higher_pict = FALSE;
	t->always_text = FALSE;

	/* Erase with "white space" */
	t->attr_blank = TERM_WHITE;
	t->char_blank = ' ';

	/* Hooks */
	t->xtra_hook = Term_xtra_sdl;
	t->curs_hook = Term_curs_sdl;
	t->wipe_hook = Term_wipe_sdl;
	t->text_hook = Term_text_sdl;

	/* Save the data */
	t->data = td;

	/* Activate (important) */
	Term_activate(t);

	/************* finish term_data intializing */
	
	/* name of this term window */
	td->name = angband_term_name[i];

	/* For now, all font is the same size... use global t_width/height */
	td->tile_width = t_width;
	td->tile_height = t_height;

	/* Now calculate the total width and height*/
	CALCULATE_SIZE(td);
	
	/* Turn on a border, thickness specified by BORDER_THICKNESS */
	td->has_border = TRUE;
	td->border_thick = BORDER_THICKNESS;

#ifdef USE_GRAPHICS
#ifdef USE_TRANSPARENCY
#endif
#endif

	/* Success */
	return (0);
}

/* dumpWindowSettings is responsible for exporting all current
values of the window positions, etc. to the screen, so that 
the user can see what the final values were after tweaking */
void dumpWindowSettings(void)
{
	char name[80];
	char value[8];
	int i;
	
	DB("Dumping settings");
	/* cycle through each available terminal */
	for (i=0; i<arg_console_count; i++)
	{
		printf("Terminal %d:\n",i);
		/* get the name, and value of each value to dump */
		sprintf(name,"TOME_X_POS_%d",i);
		sprintf(value,"%d",data[i].pos_x);
		printf("%s=%s\n",name,value);

		sprintf(name,"TOME_Y_POS_%d",i);
		sprintf(value,"%d",data[i].pos_y);
		printf("%s=%s\n",name,value);		

		sprintf(name,"TOME_NUM_COLS_%d",i);
		sprintf(value,"%d",data[i].cols);
		printf("%s=%s\n",name,value);		

		sprintf(name,"TOME_NUM_ROWS_%d",i);
		sprintf(value,"%d",data[i].rows);
		printf("%s=%s\n",name,value);		

		/* Simple! */
		printf("\n");
	}
}

#ifdef PRIVATE_USER_PATH

/*
 * Check and create if needed the directory dirpath -- copied from main.c
 */
bool private_check_user_directory(cptr dirpath)
{
	/* Is this used anywhere else in *bands? */
	struct stat stat_buf;

	int ret;

	/* See if it already exists */
	ret = stat(dirpath, &stat_buf);

	/* It does */
	if (ret == 0)
	{
		/* Now we see if it's a directory */
		if ((stat_buf.st_mode & S_IFMT) == S_IFDIR) return (TRUE);

		/*
		 * Something prevents us from create a directory with
		 * the same pathname
		 */
		return (FALSE);
	}

	/* No - this maybe the first time. Try to create a directory */
	else
	{
		/* Create the ~/.ToME directory */
		ret = mkdir(dirpath, 0700);

		/* An error occured */
		if (ret == -1) return (FALSE);

		/* Success */
		return (TRUE);
	}
}

/*
 * Check existence of ".ToME/" directory in the user's
 * home directory or try to create it if it doesn't exist.
 * Returns FALSE if all the attempts fail.
 */
static bool check_create_user_dir(void)
{
	char dirpath[1024];
	char versionpath[1024];
	char savepath[1024];

	/* Get an absolute path from the filename */
	path_parse(dirpath, 1024, PRIVATE_USER_PATH);
	strcpy(versionpath, dirpath);
	strcat(versionpath, USER_PATH_VERSION);
	strcpy(savepath, versionpath);
	strcat(savepath, "/save");

	return private_check_user_directory(dirpath) && private_check_user_directory(versionpath) && private_check_user_directory(savepath);
}

#endif /* PRIVATE_USER_PATH */

/*
 * Init some stuff - copied from main.c
 */
static void init_stuff(void)
{
	char path[1024];

	cptr tail;

	/* Get the environment variable */
	tail = getenv("TOME_PATH");

	/* Use the angband_path, or a default */
#ifndef ENABLE_BINRELOC
	strcpy(path, tail ? tail : DEFAULT_PATH);
#else /* Runtime lookup of location */
	strcpy(path, br_strcat(DATADIR, "/tome/lib"));
#endif

	/* Hack -- Add a path separator (only if needed) */
	if (!suffix(path, PATH_SEP)) strcat(path, PATH_SEP);

	/* Initialize */
	init_file_paths(path);
}


errr init_sdl(int argc, char **argv)
{
	return 0;
}

/*************************************************
 MAIN!!! (Finally!)
 *************************************************/

int main(int argc, char *argv[])
{
	int i;

	bool done = FALSE;

	bool new_game = FALSE;

	int show_score = 0;

	cptr mstr = NULL;

	bool args = TRUE;

	float gamma;
	char filename[PATH_MAX + 1];
	/* Flags to pass to SDL_SetVideoMode */
	int videoFlags;
	/* this holds some info about our display */
	const SDL_VideoInfo *videoInfo;


#ifdef CHECK_MEMORY_LEAKS
	GC_find_leak = 1;
#endif /* CHECK_MEMORY_LEAKS */


	/* Save the "program name" XXX XXX XXX */
	argv0 = argv[0];


#ifdef USE_286
	/* Attempt to use XMS (or EMS) memory for swap space */
	if (_OvrInitExt(0L, 0L))
	{
		_OvrInitEms(0, 0, 64);
	}
#endif


#ifdef SET_UID

	/* Default permissions on files */
	(void)umask(022);

#endif /* SET_UID */


	/* Get the file paths */
	init_stuff();


#ifdef SET_UID

	/* Get the user id (?) */
	player_uid = getuid();

#ifdef VMS
	/* Mega-Hack -- Factor group id */
	player_uid += (getgid() * 1000);
#endif

# ifdef SAFE_SETUID

# ifdef _POSIX_SAVED_IDS

	/* Save some info for later */
	player_euid = geteuid();
	player_egid = getegid();

# endif

# if 0	/* XXX XXX XXX */

	/* Redundant setting necessary in case root is running the game */
	/* If not root or game not setuid the following two calls do nothing */

	if (setgid(getegid()) != 0)
	{
		sdl_quit("setgid(): cannot set permissions correctly!");
	}

	if (setuid(geteuid()) != 0)
	{
		sdl_quit("setuid(): cannot set permissions correctly!");
	}

# endif  /* XXX XXX XXX */

# endif  /* SAFE_SETUID */

#endif /* SET_UID */


#ifdef SET_UID

	/* Please note that the game is still running in the game's permission */

	/* Initialize the "time" checker */
	if (check_time_init() || check_time())
	{
		sdl_quit("The gates to Angband are closed (bad time).");
	}

	/* Initialize the "load" checker */
	if (check_load_init() || check_load())
	{
		sdl_quit("The gates to Angband are closed (bad load).");
	}


	/*
	 * Become user -- This will be the normal state for the rest of the game.
	 *
	 * Put this here because it's totally irrelevant to single user operating
	 * systems, as witnessed by huge number of cases where these functions
	 * weren't used appropriately (at least in this variant).
	 *
	 * Whenever it is necessary to open/remove/move the files in the lib folder,
	 * this convention must be observed:
	 *
	 *    safe_setuid_grab();
	 *
	 *    fd_open/fd_make/fd_kill/fd_move which requires game's permission,
	 *    i.e. manipulating files under the lib directory
	 *
	 *    safe_setuid_drop();
	 *
	 * Please never ever make unmatched calls to these grab/drop functions.
	 *
	 * Please note that temporary files used by various information commands
	 * and ANGBAND_DIR_USER files shouldn't be manipulated this way, because
	 * they reside outside of the lib directory on multiuser installations.
	 * -- pelpel
	 */
	safe_setuid_drop();


	/* Acquire the "user name" as a default player name */
	user_name(player_name, player_uid);


#ifdef PRIVATE_USER_PATH

	/*
	 * On multiuser systems, users' private directories are
	 * used to store pref files, chardumps etc.
	 */
	{
		bool ret;

		/* Create a directory for the user's files */
		ret = check_create_user_dir();

		/* Oops */
		if (ret == FALSE) sdl_quit("Cannot create directory " PRIVATE_USER_PATH);
	}

#endif /* PRIVATE_USER_PATH */

#endif /* SET_UID */

	/* Before sdl_quit could possible be called, need to make sure that the text
	array is zeroed, so that sdl_quit->killFontAndAlphabet() doesn't try to free
	SDL_Surfaces that don't exist ! */
	memset(text,0,sizeof(text));

	/* Initialize the SDL window*/
	filename[PATH_MAX] = 0;

	/* initialize SDL */
	if ( SDL_Init( SDL_INIT_VIDEO ) < 0 )
	{
		sdl_quit("Video initialization failed!");
	}
	DB("SDL Initialized!");

	/* Skip to our arguments -- (Neil)*/
	for (i = 1; (i < argc) && (0 != strcmp(argv[i], "--")); ++i);
	/* Handle our arguments -- (Neil)*/
	for (++i; i < argc ; ++i)
	{
		if (0 == strcmp(argv[i], "-n"))
		{
			if (++i == argc)
			{
				printf("Argument missing for option -n\n");
				return -1;
			}
			
			arg_console_count = atoi(argv[i]);
			if (arg_console_count <= 0 || \
				arg_console_count > MAX_CONSOLE_COUNT)
			{
				printf("Invalid console count given.\n");
				arg_console_count = 1;
			}
		}
	 /*
	 else if (0 == strcmp(argv[i], "-o"))
	 {
	 arg_old_graphics = TRUE;
	 }
	 else if (0 == strcmp(argv[i], "-b"))
	 {
	 arg_double_width = TRUE;
	 }
	*/
		else if (0 == strcmp(argv[i], "-w"))
	 	{
			if (++i == argc)
			{
				printf("Argument missing for option -w\n");
				return -1;
			}
			
			arg_width = atoi(argv[i]);
		}
		else if (0 == strcmp(argv[i], "-h"))
		{
			if (++i == argc)
			{
				printf("Argument missing for option -h\n");
				return -1;
			}
		
			arg_height = atoi(argv[i]);
		}
	 /*
	 else if (0 == strcmp(argv[i], "-fs"))
	 {
	 arg_full_screen = TRUE;
	 }
	 */
		else if (0 == strcmp(argv[i], "-bpp"))
		{
			if (++i == argc)
			{
				printf("Argument missing for option -bpp\n");
				return -1;
			}
			
			arg_bpp = atoi(argv[i]);
		}
	}

	/* Now for the meat of the initialization -- (Neil)*/
	quit_aux = sdl_quit;

	/* Window Manager stuff -- (Neil)*/
	path_build(filename, PATH_MAX, ANGBAND_DIR_XTRA, "graf/icon.png");
	SDL_WM_SetIcon(IMG_Load(filename), 0);
	SDL_WM_SetCaption("ToME", "tome");

	/* how about a hardware surface with hardware palette?
	XXX XXX XXX should probably be chosen at compile-time! */
	videoFlags = SDL_HWSURFACE | SDL_HWPALETTE;

	/* XXX XXX XXX */
	if(getenv("TOME_SCREEN_WIDTH")) arg_width = atoi(getenv("TOME_SCREEN_WIDTH"));
	if(getenv("TOME_SCREEN_HEIGHT")) arg_height = atoi(getenv("TOME_SCREEN_HEIGHT"));
	if(getenv("TOME_SCREEN_BPP")) arg_bpp = atoi(getenv("TOME_SCREEN_BPP"));

	/* get a SDL surface */
	screen = SDL_SetVideoMode( arg_width, arg_height, arg_bpp, videoFlags );

	DB("Video Mode Set!");

	/* Verify there is a surface */
	if ( !screen )
	{
		DB("No screen!");
		sdl_quit("Failed to set SDL Surface.");
	}

	DB("SDL Window Created!");

	/* Now ready the fonts! */

	DB("initializing SDL_ttf");
	if(TTF_Init()==-1) {
		printf("TTF_Init: %s\n", TTF_GetError());
		sdl_quit("Bah");
	}

	DB("loading font...");
	/* XXX centralize these environment calls*/
	if(getenv("TOME_FONT_SIZE")) arg_font_size = atoi(getenv("TOME_FONT_SIZE"));

	/* load and render the font */
	loadAndRenderFont(arg_font_name,arg_font_size);

	/* Initialize the working surface and crayon surface used for rendering
	 text in different colors... */
	worksurf = SDL_CreateRGBSurface(SDL_HWSURFACE,t_width,\
		t_height,16,0xf000,0x0f00,0x00f0,0x000f);
	crayon = SDL_CreateRGBSurface(SDL_HWSURFACE,t_width,\
		t_height,16,0xf000,0x0f00,0x00f0,0x000f);

	/* The working surface will blit using alpha values... */
	SDL_SetAlpha(worksurf,SDL_SRCALPHA,0);

	/* Set up the colors using the great little color macros! */
	color_data[0]  = BLACK;
	color_data[1]  = WHITE;
	color_data[2]  = MID_GREY;
	color_data[3]  = BRIGHT_ORANGE;
	color_data[4]  = RED;
	color_data[5]  = GREEN;
	color_data[6]  = BRIGHT_BLUE;
	color_data[7]  = DARK_ORANGE;
	color_data[8]  = DARK_GREY;
	color_data[9]  = BRIGHT_GREY;
	color_data[10] = PURPLE;
	color_data[11] = YELLOW;
	color_data[12] = BRIGHT_RED;
	color_data[13] = BRIGHT_GREEN;
	color_data[14] = AQUAMARINE;
	color_data[15] = BROWN;

	/* And setup the basic screen colors */
	screen_black  = SDL_MapRGB(screen->format,  0,  0,  0);
	screen_white  = SDL_MapRGB(screen->format,255,255,255);
	screen_purple = SDL_MapRGB(screen->format,255,  0,255);	
	
	/* And setup the cursor, using the default color...
	XXX - in the future, this should (and will) be loaded from prefs */
	createCursor(DEF_CURSOR_COLOR);

	/* make the default terminal border color to be white */
	border_color = screen_white;
	
	/* Initialize the windows, or whatever that means in this case.
	Do this in reverse order so that the main window is on top.*/
	i = arg_console_count;
	while (i--)
	{
		term_data *td = &data[i];

		/* Initialize the term_data */
		term_data_init(td, i);

		/* Save global entry */
		angband_term[i] = Term;
	}
	/* now that the windows have been set, their settings can
	be dumped upon quit! */
	window_properties_set = TRUE;

	/* Enable UNICODE keysyms - needed for current eventHandling routine */
	SDL_EnableUNICODE(1);

	/* By setting this value, 'pref-sdl.prf' will be loaded on start.
	 Since this contains mappings for various keys, this is important! */
	ANGBAND_SYS = "sdl";


	printf("Signals?\n");

	/* Catch nasty signals */
	signals_init();

	printf("Initialize Angband!\n");
	/* Initialize */
	init_angband();

	printf("Angband Initialized!\n");

	/* Hack -- If requested, display scores and quit */
	if (show_score > 0) display_scores(0, show_score);

	/* Wait for response */
	pause_line(23);

	printf("Play the game!\n");

	/* Play the game */
	play_game(new_game);

	/* Quit */
	sdl_quit("Game over, man");

	/* Exit */
	return (0);

}

#endif
